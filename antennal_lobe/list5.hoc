{load_file ("nrngui.hoc")}
objref pc
pc = new ParallelContext()
{load_file("cellid.hoc")}
load_file("ranstream.hoc")

NCELL = 20
C_E = 3

connect_random_low_start_ = 1
objref cells, nclist

objref ranlist

proc mknet(){
    mkcells($1)
    connectcells()
}

objref gidvec
proc mkcells(){local i localobj cell,nc, nil
    cells = new List()
    ranlist = new List()
    gidvec = new Vector()
    
    for(i=pc.id; i<$1;i+=pc.nhost){
	cell = new B_BallStick()
	for j=0, cell.synlist.count-1{
	    cell.synlist.o(j).cid = i
	    cell.synlist.o(j).sid = j
	}
	
	cells.append(cell)
	pc.set_gid2node(i,pc.id)
	nc = cell.connect2target(nil)
	pc.cell(i,nc)
	ranlist.append(new RandomStream(i))
	gidvec.append(i)
    }
    report_gidvecs()
}
proc report_gidvecs(){local i, rank
    pc.barrier()
    if(pc.id==0) printf("\ngidvecs on the various hosts\n")
    for rank=0, pc.nhost-1{
	if(rank=pc.id){
	    print "host ",pc.id
	    gidvec.printf()
	}
	pc.barrier()
    }
}

proc connectcells(){local i, nsyn, r localobj syn, nc, rs, u
    mcell_ran4_init(connect_random_low_start_)
    u = new Vector(NCELL)
    nclist = new List()
    for i=0, cells.count-1{
	syn = cells.object(i).synlist.object(0)
	rs = ranlist.object(i)
	rs.start()
	rs.r.discunif(0, NCELL-1)
	u.fill(0)
	nsyn = 0
	while (nsyn<C_E){
	    r = rs.repick()
	    if(r != gidvec.x[i]) if(u.x[r] == 0){
		nc = pc.gid_connect(r,syn)
		nclist.append(nc)
		nc.delay = 1
		nc.weight = 0.01
		u.x[r] = 1
		nsyn +=1
	    }
	}
    }
}
mknet (NCELL)

proc tracenet(){local i, srcid localobj src, tgt, nil
    pc.barrier()
    if(pc.id ==0) printf("source\ttarget\tsynapse\n")
    for rank = 0, pc.nhost -1{
	if(rank == pc.id){
	    for i = 0, nclist.count-1{
		srcid = nclist.o(i).srcgid()
		tgt = nclist.o(i).syn
		printf("%d\t%d\t%d\n",srcid, tgt.cid, tgt.sid)
	    }
	}
	pc.barrier()
	print "barrier"
    }
}
tracenet()

objref stim, ncstim
proc mkstim(){
    if(!pc.gid_exists(0)){return }
    print"mkstim"
    stim = new NetStim()
    stim.number = 1
    stim.start = 0
    ncstim = new NetCon(stim, pc.gid2cell(0).synlist.object(0))
    ncstim.delay = 0
    ncstim.weight = 0.01
}
mkstim()

objref tvec, idvec
proc spikerecord(){local i localobj nc, nil
    print"spikerecord"
    tvec = new Vector()
    idvec = new Vector()
    for i = 0, cells.count -1{
	nc = cells.object(i).connect2target(nil)
	nc.record(tvec,idvec,nc.srcgid)
    }
}
spikerecord()
print "run"
tstop = 100
{pc.set_maxstep(10)}
stdinit()
{pc.psolve (tstop)}
print "spikeout"
proc spikeout(){local i, rank
    pc.barrier()
    if(pc.id==0) printf("\ntime\t cell\n")
    for rank=0, pc.nhost -1{
	if(rank==pc.id){
	    for i = 0, tvec.size -1{
		printf("%g\t %d\n",tvec.x[i],idvec.x[i])
	    }
	}
	pc.barrier()
    }
}
print "spikeout"
spikeout()
{pc.runworker()}
{pc.done()}
quit()
